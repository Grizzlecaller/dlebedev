Контрольные вопросы:

1. Что такое “коллекция”.

из https://pro-java.ru/java-dlya-nachinayushhix/kollekcii-v-java-chto-eto-takoe-i-zachem-oni-nuzhny/
Коллекция - это объект, способный хранить группу одинаковых элементов.
Она содержит методы для операций с однородными данными.

2. Назовите преимущества использования коллекций.

из http://javastudy.ru/interview/collections/

Надо перефразировать этот текст

Массивы обладают значительными недостатками.
Одним из них является конечный размер массива, как следствие, необходимость следить за размером массива.
Другим — индексная адресация, что не всегда удобно, т.к. ограничивает возможности добавления и удаления объектов.
Чтобы избавиться от этих недостатков уже несколько десятилетий программисты используют рекурсивные типы данных, такие как списки и деревья.
Стандартный набор коллекций Java служит для избавления программиста от необходимости самостоятельно реализовывать эти типы данных
и снабжает его дополнительными возможностями.

3. Какие данные могут хранить коллекции?

Любые ссылочные типы данных.
(классы, перечисления и интерфейсы, например, объявленные в стандартной библиотеке Java, а также массивы.)

4. Какие есть типы коллекций? Как они характеризуются?

Collection: базовый интерфейс для всех коллекций и других интерфейсов коллекций

Queue: наследует интерфейс Collection и представляет функционал для структур данных в виде очереди

Deque: наследует интерфейс Queue и представляет функционал для двунаправленных очередей

List: наследует интерфейс Collection и представляет функциональность простых списков

Set: также расширяет интерфейс Collection и используется для хранения множеств уникальных объектов

SortedSet: расширяет интерфейс Set для создания сортированных коллекций

NavigableSet: расширяет интерфейс SortedSet для создания коллекций, в которых можно осуществлять поиск по соответствию

Map: предназначен для созданий структур данных в виде словаря, где каждый элемент имеет определенный ключ и значение.
В отличие от других интерфейсов коллекций не наследуется от интерфейса Collection

5. Назовите основные реализации List, Set, Map.

из: http://javastudy.ru/interview/collections/

List :

ArrayList - список
LinkedList - список
Vector - вектор
Stack - стек

Set:

HashSet - множество
TreeSet - множество
SortedSet - отсортированное множество

Map:

HashMap - карта
TreeMap - карта
SortedMap - отсортированная карта
Hashtable - хеш-таблица

6. В чём отличие ArrayList от LinkedList?

из https://habr.com/ru/post/162017/

ArrayList - список, реализованный на основе массива.
Имеет размер n=10, по умолчанию. при добавлении n+1 элемента будет создан новый список размером (n * 3)\2 + 1,
в него будут помещены элементы старого списка + новый элемент.
Получается, что при добавлении элемента с необходимостью расширения массива больше чем при записи элемента в пустую ячейку.

Преимущества:
- имеет доступ к любому элементу по индексу;
- Элементы хранятся массивом

Недостатки:
- при удалении элемента  из середины списка происходит перезапись всех элементов правее удаляемого элемента на одну позицию влево;
- при удалении элементов размер списка не уменьшается, без явного вызова метода trimToSize().

LinkedList - является двунаправленным списком, где каждый элемент имеет указатели на предыдущий и следующий элемент списка.

"из https://habr.com/ru/post/337558/
LinkedList — класс, реализующий два интерфейса — List и Deque.
Это обеспечивает возможность создания двунаправленной очереди из любых (в том числе и null) элементов.
Каждый объект, помещенный в связанный список, является узлом (нодом).
Каждый узел содержит элемент, ссылку на предыдущий и следующий узел.
Фактически связанный список состоит из последовательности узлов, каждый из которых предназначен для хранения объекта определенного
при создании типа."

Преимущества:

- Позволяет хранить любые объекты, в том числе null и повторяющиеся.
- запись элемента в конец списка происходит за постоянное время, т.к. ссылки на первый и последний элемент хранятся.
Не нужно перебирать список в поисках последнего элемента.
- Предпочтительное применение с случаях постоянного добавления/удаления элементов в середине списка.


7. В чём отличие HashSet от TreeSet?

Set не допускает хранение двух одинаковых элементов.

HashSet:
- разрешает null объект
- не гарантирует что порядок элементов будех сохраняться с течением времени

TreeSet:
- не разрешает null объект (при попытке добавления вызовет исключение NullPointerException)
- гарантирует что элементы будут отсортированы(восходящие, естественные или заданные через его конструктор SortedSet)

8. В чём отличие Set от Map?

Set:
- это коллекции, которые содержат в себе только уникальные элементы
- не допускает хранение двух одинаковых элементов


Map:
- это интерфейс для реализации карты, где элементы хранятся с их клдчами

9. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?


Comparator описывает два метода сравления:

1) int compare(Object obj1, object obj2) — возвращает отрицательное число, если obj1 в каком-то смысле меньше obj2;
нуль, если они считаются равными;
положительное число, если obj1 больше obj2.

2) boolean equals(Object obj) — сравнивает данный объект с объектом obj,
возвращая true, если объекты совпадают в каком-либо смысле, заданном этим методом.


//Коллекции не имеют предопределенного порядка, поэтому, что бы отсортировать их,
необходимо преобразовать коллекцию в List.
После этого необходимо использовать Collection.sort().

10. Чем отличается Comparable от Comparator?

из: https://ru.stackoverflow.com/questions/586205/Чем-отличается-comparable-от-comparator

Comparable - реализуется внутри класса. По сути, определяет обычный/естественный порядок сравнения объектов.

Comparator - реализуется вне класса. Можно реализовать различные варианты сортировки, основанные на сравнении различных полей.

11. Что такое сортировка по принципу Natural Order?

из: https://javarush.ru/groups/posts/2262-comparator-v-java

Реализованный в Comparable метод сравнения.

Natural Ordering уже присутствует в Java.
Например, Java знает, что строки чаще всего сортируют по алфавиту, а числа — по возрастанию их значения.
Поэтому если вызвать на списке чисел или строк метод sort(), так они и будут отсортированы.

12. Что такое equals и hashcode?

equals:
Используется для сравнения объектов.
Сравнивает ссылки на адреса в памяти, которые хранят переменные.
Вовращает true только если адреса совпадают (переменные ссылаются на один и тот же объект)

hashcode:
Используется для генерации целочисленного кода объекта.
Этот код позволяет быстро определить местонахождение объекта в коллекции типа
HashSet и извлечь.
hashCode() - возвращает целое число int размером 32бит(4 байта).

13. Какие есть способы перебора всех элементов List?

for
forech
while
Цикл с итератором

14. Как реализован цикл foreach?

Реализован на основе iterator.
for(тип итер_пер : коллекция) блок_операторов

15. В чем разница между Iterator и ListIterator?

Iterator - используется для перемения по List, Set и Map в одном направлении

Методы Iterator:
- hasNext()
- next()
- remove()

ListIterator:
- используется для перемещения только по List в двух направлениях
- можно получить индекс в любой точке

Методы ListIterator:
- boolean hasNext();
- E next();
- boolean hasPrevious();
- E previous();
- int nextIndex();
- int previousIndex();
- void remove(); //optional
- void set(E e); //optional
- void add(E e); //optional

16. Как происходит удаление элементов из ArrayList?

из https://habr.com/ru/post/162017/

При удалении элемента из списка происходит перезапись всех элементов справа от удаляемого элемента на одну ячейку влево,
при этом размер списка не уменьшается, пока явно не использовать метод trimToSize().

17. Как происходит удаление элементов из LinkedList?

из https://habr.com/ru/post/337558/

У LinkedList есть 10 метобов удаления элемента:
- poll()                     - удаляемый элемент первый - если найден- возвращает удаляемый элемент - если не найден- возвращает null
- pollFirst()                - удаляемый элемент первый - если найден- возвращает удаляемый элемент - если не найден- возвращает null
- remove()                   - удаляемый элемент первый - если найден- возвращает удаляемый элемент - если не найден- NoSuchElementException
- removeFirst()              - удаляемый элемент первый - если найден- возвращает удаляемый элемент - если не найден- NoSuchElementException
- pollLast()                 - удаляемый элемент последний - если найден- возвращает удаляемый элемент - если не найден- возвращает null
- removeLast()               - удаляемый элемент последний - если найден- возвращает удаляемый элемент - если не найден- NoSuchElementException
- remove(index)              - удаляемый элемент в указанной позиции - если найден- возвращает удаляемый элемент - если не найден- IndexOutOfBoundException
- remove(object)             - удаляемый элемент первое вхождение указанногообъекта - если найден- возвращает true - если не найден- возвращает false
- removeFirstOccurrence()    - удаляемый элемент первое вхождение указанного объекта - если найден- возвращает true - если не найден- возвращает false
- removeLastOccurrence()     - удаляемый элемент последнее вхождение указанного объекта - если найден- возвращает true - если не найден- возвращает false

Сначала искомый объект сравниваетя со всеми элементами, сохраненныи в узлах списка, начиная с нулевого.
Если найден узел, элемент которого равен искомому объекту, этот элеимент сохраняется в отдельную переменную.
После чего переопределяются ссылки соседних узлов так, что бы они указывали друг на друга.
Замет обнуляется начение узла, который содержит удаляемый объект и уменьшается размер коллекции.

когда мы используем метод remove(index), также вызывающий метод unlink(node), то значение данного элемента последовательно
возвращается сначала методом unlink(node), а затем и методом remove(index).
Похожая ситуация наблюдается и в остальных методах, возвращающих значение удаленного элемента,
только внутри вызываются другие методы, отсоединяющие ссылку: в методах poll(), pollFirst(), remove() и removeFirst() это метод unlinkFirst(node),
а в методах pollLast() и removeLast() — метод unlinkLast(node).
